from typing import Any,Sequence,Tuple,Union,overload
class Color:
 def __init__(self,rgb:Sequence[float])->None:...
 def copy(self)->'Color':...
 def freeze(self)->'Color':...
 def from_aces_to_scene_linear(self)->'Color':...
 def from_rec709_linear_to_scene_linear(self)->'Color':...
 def from_scene_linear_to_aces(self)->'Color':...
 def from_scene_linear_to_rec709_linear(self)->'Color':...
 def from_scene_linear_to_srgb(self)->'Color':...
 def from_scene_linear_to_xyz_d65(self)->'Color':...
 def from_srgb_to_scene_linear(self)->'Color':...
 def from_xyz_d65_to_scene_linear(self)->'Color':...
 b:float
 g:float
 h:float
 hsv:Tuple[float,float,float]
 is_frozen:bool
 is_valid:bool
 is_wrapped:bool
 owner:Any
 r:float
 s:float
 v:float
 def __add__(self,other:'Color')->'Color':...
 def __iadd__(self,other:'Color')->'Color':...
 def __sub__(self,other:'Color')->'Color':...
 def __isub__(self,other:'Color')->'Color':...
 def __mul__(self,other:float)->'Color':...
 def __rmul__(self,other:float)->'Color':...
 def __imul__(self,other:float)->'Color':...
 def __getitem__(self,key:int)->float:...
 def __setitem__(self,key:int,value:float)->None:...
class Euler:
 def __init__(self,angles:Sequence[float],order:str='XYZ')->None:...
 def copy(self)->'Euler':...
 def freeze(self)->'Euler':...
 def make_compatible(self,other:'Euler')->None:...
 def rotate(self,other:Union['Euler','Quaternion','Matrix'])->None:...
 def rotate_axis(self,axis:str,angle:float)->None:...
 def to_matrix(self)->'Matrix':...
 def to_quaternion(self)->'Quaternion':...
 def zero(self)->None:...
 is_frozen:bool
 is_valid:bool
 is_wrapped:bool
 order:str
 owner:Any
 x:float
 y:float
 z:float
 def __getitem__(self,key:int)->float:...
 def __setitem__(self,key:int,value:float)->None:...
class Matrix:
 def __init__(self,rows:Sequence[Sequence[float]]=...)->None:...
 @classmethod
 def Diagonal(cls,vector:'Vector')->'Matrix':...
 @classmethod
 def Identity(cls,size:int)->'Matrix':...
 @classmethod
 def LocRotScale(cls,location:Union['Vector',None],rotation:Union['Matrix','Quaternion','Euler',None],scale:Union['Vector',None])->'Matrix':...
 @classmethod
 def OrthoProjection(cls,axis:Union[str,'Vector'],size:int)->'Matrix':...
 @classmethod
 def Rotation(cls,angle:float,size:int,axis:Union[str,'Vector'])->'Matrix':...
 @classmethod
 def Scale(cls,factor:float,size:int,axis:'Vector')->'Matrix':...
 @classmethod
 def Shear(cls,plane:str,size:int,factor:Union[float,Sequence[float]])->'Matrix':...
 @classmethod
 def Translation(cls,vector:'Vector')->'Matrix':...
 def adjugate(self)->None:...
 def adjugated(self)->'Matrix':...
 def copy(self)->'Matrix':...
 def decompose(self)->Tuple['Vector','Quaternion','Vector']:...
 def determinant(self)->float:...
 def freeze(self)->'Matrix':...
 def identity(self)->None:...
 def invert(self,fallback:Union['Matrix',None]=None)->None:...
 def invert_safe(self)->None:...
 def inverted(self,fallback:Any=None)->Union['Matrix',Any]:...
 def inverted_safe(self)->'Matrix':...
 def lerp(self,other:'Matrix',factor:float)->'Matrix':...
 def normalize(self)->None:...
 def normalized(self)->'Matrix':...
 def resize_4x4(self)->None:...
 def rotate(self,other:Union['Euler','Quaternion','Matrix'])->None:...
 def to_2x2(self)->'Matrix':...
 def to_3x3(self)->'Matrix':...
 def to_4x4(self)->'Matrix':...
 def to_euler(self,order:str='',euler_compat:Union['Euler',None]=None)->'Euler':...
 def to_quaternion(self)->'Quaternion':...
 def to_scale(self)->'Vector':...
 def to_translation(self)->'Vector':...
 def transpose(self)->None:...
 def transposed(self)->'Matrix':...
 def zero(self)->None:...
 col:Any
 is_frozen:bool
 is_identity:bool
 is_negative:bool
 is_orthogonal:bool
 is_orthogonal_axis_vectors:bool
 is_valid:bool
 is_wrapped:bool
 median_scale:float
 owner:Any
 row:Any
 translation:'Vector'
 def __add__(self,other:'Matrix')->'Matrix':...
 def __sub__(self,other:'Matrix')->'Matrix':...
 def __mul__(self,other:Union[float,'Matrix'])->'Matrix':...
 def __rmul__(self,other:float)->'Matrix':...
 def __matmul__(self,other:Union['Matrix','Vector'])->Union['Matrix','Vector']:...
 @overload
 def __matmul__(self,other:'Matrix')->'Matrix':...
 @overload
 def __matmul__(self,other:'Vector')->'Vector':...
 def __getitem__(self,key:Tuple[int,int])->float:...
 def __setitem__(self,key:Tuple[int,int],value:float)->None:...
class Quaternion:
 def __init__(self,seq:Sequence[float]=(1,0,0,0))->None:...
 def conjugate(self)->None:...
 def conjugated(self)->'Quaternion':...
 def copy(self)->'Quaternion':...
 def cross(self,other:'Quaternion')->'Quaternion':...
 def dot(self,other:'Quaternion')->float:...
 def freeze(self)->'Quaternion':...
 def identity(self)->None:...
 def invert(self)->None:...
 def inverted(self)->'Quaternion':...
 def make_compatible(self,other:'Quaternion')->None:...
 def negate(self)->None:...
 def normalize(self)->None:...
 def normalized(self)->'Quaternion':...
 def rotate(self,other:Union['Euler','Quaternion','Matrix'])->None:...
 def rotation_difference(self,other:'Quaternion')->'Quaternion':...
 def slerp(self,other:'Quaternion',factor:float)->'Quaternion':...
 def to_axis_angle(self)->Tuple['Vector',float]:...
 def to_euler(self,order:str,euler_compat:'Euler')->'Euler':...
 def to_exponential_map(self)->'Vector':...
 def to_matrix(self)->'Matrix':...
 def to_swing_twist(self,axis:str)->Tuple['Quaternion',float]:...
 angle:float
 axis:'Vector'
 is_frozen:bool
 is_valid:bool
 is_wrapped:bool
 magnitude:float
 owner:Any
 w:float
 x:float
 y:float
 z:float
 def __add__(self,other:'Quaternion')->'Quaternion':...
 def __sub__(self,other:'Quaternion')->'Quaternion':...
 def __mul__(self,other:Union[float,'Quaternion'])->'Quaternion':...
 def __rmul__(self,other:float)->'Quaternion':...
 def __matmul__(self,other:Union['Quaternion','Vector'])->Union['Quaternion','Vector']:...
 def __eq__(self,other:object)->bool:...
 def __ne__(self,other:object)->bool:...
 def __neg__(self)->'Quaternion':...
 def __getitem__(self,key:int)->float:...
 def __setitem__(self,key:int,value:float)->None:...
class Vector:
 def __init__(self,seq:Sequence[float])->None:...
 @classmethod
 def Fill(cls,size:int,fill:float=0.0)->'Vector':...
 @classmethod
 def Linspace(cls,start:int,stop:int,size:int)->'Vector':...
 @classmethod
 def Range(cls,start:int,stop:int,step:int=1)->'Vector':...
 @classmethod
 def Repeat(cls,vector:'Vector',size:int)->'Vector':...
 def angle(self,other:'Vector',fallback:Any=None)->float:...
 def angle_signed(self,other:'Vector',fallback:Any=None)->float:...
 def copy(self)->'Vector':...
 def cross(self,other:'Vector')->'Vector':...
 def dot(self,other:'Vector')->float:...
 def freeze(self)->'Vector':...
 def lerp(self,other:'Vector',factor:float)->'Vector':...
 def negate(self)->None:...
 def normalize(self)->None:...
 def normalized(self)->'Vector':...
 def orthogonal(self)->'Vector':...
 def project(self,other:'Vector')->'Vector':...
 def reflect(self,mirror:'Vector')->'Vector':...
 def resize(self,size:int)->None:...
 def resize_2d(self)->None:...
 def resize_3d(self)->None:...
 def resize_4d(self)->None:...
 def resized(self,size:int)->'Vector':...
 def rotate(self,other:Union['Euler','Quaternion','Matrix'])->None:...
 def rotation_difference(self,other:'Vector')->'Quaternion':...
 def slerp(self,other:'Vector',factor:float,fallback:Any=None)->'Vector':...
 def to_2d(self)->'Vector':...
 def to_3d(self)->'Vector':...
 def to_4d(self)->'Vector':...
 def to_track_quat(self,track:str,up:str)->'Quaternion':...
 def to_tuple(self,precision:int=-1)->Tuple[float,...]:...
 def zero(self)->None:...
 is_frozen:bool
 is_valid:bool
 is_wrapped:bool
 length:float
 length_squared:float
 magnitude:float
 owner:Any
 w:float
 x:float
 y:float
 z:float
 def __add__(self,other:'Vector')->'Vector':...
 def __sub__(self,other:'Vector')->'Vector':...
 def __mul__(self,other:Union[float,'Matrix','Quaternion'])->'Vector':...
 def __rmul__(self,other:float)->'Vector':...
 def __truediv__(self,other:float)->'Vector':...
 def __neg__(self)->'Vector':...
 def __getitem__(self,key:int)->float:...
 def __setitem__(self,key:int,value:float)->None:...
class BVHTree:
 @classmethod
 def FromBMesh(cls,bmesh:Any,epsilon:float=0.0)->'BVHTree':...
 @classmethod
 def FromObject(cls,object:Any,depsgraph:Any,deform:bool=True,render:bool=False,cage:bool=False,epsilon:float=0.0)->'BVHTree':...
 @classmethod
 def FromPolygons(cls,vertices:Sequence['Vector'],polygons:Sequence[Sequence[int]],all_triangles:bool=False,epsilon:float=0.0)->'BVHTree':...
 def find(self,origin:'Vector',direction:'Vector')->Tuple['Vector','Vector',float,int]:...
 def overlap(self,other_tree:'BVHTree')->Sequence[Tuple[int,int]]:...
 def ray_cast(self,origin:'Vector',direction:'Vector')->Tuple['Vector','Vector',float,int]:...
class KDTree:
 def __init__(self,size:int)->None:...
 def balance(self)->None:...
 def find(self,co:'Vector')->Tuple['Vector',int,float]:...
 def find_n(self,co:'Vector',n:int)->Sequence[Tuple['Vector',int,float]]:...
 def find_range(self,co:'Vector',radius:float)->Sequence[Tuple['Vector',int,float]]:...
 def insert(self,co:'Vector',index:int)->None:...
def interpolate_poly_3d(projverts:Sequence[Tuple[float,float]],((x1,y1,x2,y2):Tuple[float,float,float,float],point:Tuple[float,float])->float:...
def intersect_line_line(v1:'Vector',v2:'Vector',v3:'Vector',v4:'Vector')->Tuple['Vector','Vector']:...
def intersect_line_plane(line_a:'Vector',line_b:'Vector',plane_co:'Vector',plane_no:'Vector')->'Vector':...
def intersect_line_sphere(line_a:'Vector',line_b:'Vector',sphere_co:'Vector',sphere_radius:float)->Tuple['Vector','Vector']:...
def intersect_line_sphere_2d(line_a:'Vector',line_b:'Vector',sphere_co:'Vector',sphere_radius:float)->Tuple['Vector','Vector']:...
def intersect_plane_plane(plane_a_co:'Vector',plane_a_no:'Vector',plane_b_co:'Vector',plane_b_no:'Vector')->Tuple['Vector','Vector']:...
def intersect_point_line(pt:'Vector',line_a:'Vector',line_b:'Vector')->Tuple['Vector',float]:...
def intersect_point_quad_2d(pt:'Vector',quad_a:'Vector',quad_b:'Vector',quad_c:'Vector',quad_d:'Vector')->bool:...
def intersect_point_tri(pt:'Vector',tri_co:'Vector',tri_no:'Vector')->float:...
def intersect_point_tri_2d(pt:'Vector',v1:'Vector',v2:'Vector',v3:'Vector')->bool:...
def intersect_sphere_sphere_2d(p_a:'Vector',radius_a:float,p_b:'Vector',radius_b:float)->Tuple['Vector','Vector']:...
def normal(vectors:Sequence['Vector'])->'Vector':...
def barycentric_transform(point:'Vector',tri_a1:'Vector',tri_a2:'Vector',tri_a3:'Vector',tri_b1:'Vector',tri_b2:'Vector',tri_b3:'Vector')->'Vector':...
def distance_point_to_plane(pt:'Vector',plane_co:'Vector',plane_no:'Vector')->float:...
def volume_tetrahedron(v1:'Vector',v2:'Vector',v3:'Vector',v4:'Vector')->float:...
class noise:
 def cell(position:'Vector')->float:...
 def fractal(position:'Vector',H:float,lacunarity:float,octaves:int,noise_basis:str='PERLIN_ORIGINAL')->float:...
 def hetero_terrain(position:'Vector',H:float,lacunarity:float,octaves:int,offset:float,noise_basis:str='PERLIN_ORIGINAL')->float:...
 def hybrid_multi_fractal(position:'Vector',H:float,lacunarity:float,octaves:int,offset:float,gain:float,noise_basis:str='PERLIN_ORIGINAL')->float:...
 def multi_fractal(position:'Vector',H:float,lacunarity:float,octaves:int,noise_basis:str='PERLIN_ORIGINAL')->float:...
 def random()->float:...
 def random_unit_vector(size:int=3)->'Vector':...
 def ridged_multi_fractal(position:'Vector',H:float,lacunarity:float,octaves:int,offset:float,gain:float,noise_basis:str='PERLIN_ORIGINAL')->float:...
 def seed_set(seed:int)->None:...
 def turbulence(position:'Vector',octaves:int,hard:bool,noise_basis:str='PERLIN_ORIGINAL',amplitude_scale:float=0.5,frequency_scale:float=2.0)->float:...
 def turbulence_vector(position:'Vector',octaves:int,hard:bool,noise_basis:str='PERLIN_ORIGINAL',amplitude_scale:float=0.5,frequency_scale:float=2.0)->'Vector':...
 def variable_lacunarity(position:'Vector',distortion:float,noise_type1:str='PERLIN_ORIGINAL',noise_type2:str='PERLIN_ORIGINAL')->float:...
 def voronoi(position:'Vector',distance_type:str='F1',feature:str='F1',exponent:float=2.5)->Tuple['Vector',float,float,'Vector']:...